#!/usr/bin/env ruby


###############################################################################
# This is stack usage analysis script.                                        #
#                                                                             #
# Produces 'stackgraph.png' file as the output.                               #
#                                                                             #
# Original version: [1]. See also [2].                                        #
# TODO: re-implement in C++, using both cflow and objdump information to      #
#       create the tree (graph).                                              #
# NOTE: objdump and cflow don't see callbacks, so stack graph won't account   #
#       for callbacks, which makes this method imprecise. Real stack info     #
#       can be seen only in run-time, as we'll know how callbacks are         #
#       assigned only in run-time; see -finstrument-functions for details.    #
#                                                                             #
# [1] https://people.freedesktop.org/~siamashka/files/20150114-spl-stackgraph/#
# [2] https://github.com/johnyf/pycflow2dot
###############################################################################

require 'find'

###############################################################################

if !File.directory?("src")
  abort("Error: can't find the 'src' directory.\n" +
        "Please ensure that you are in the root of your project source tree.\n")
end

def tool_exists(tool_name)
    `which #{tool_name} > /dev/null 2>&1`
    return $?.to_i == 0
end

if !tool_exists("dot")
  abort("Please install the graphviz dot tool.\n")
end

###############################################################################
# Get objdump log                                                             #
###############################################################################

# Get the information from the environment
$toolchain = ENV["CROSS_COMPILE"]
if !$toolchain
  abort("Error: can't find a usable toolchain.\n" +
        "Try to set the CROSS_COMPILE environment variable.\n")
end

if !File.file?("kclock.elf")
  abort("Error: kclock.elf does not exist\n" +
        "Have you run \"make\"?\n")
end

$objdump_dis_log = `#{$toolchain}objdump -d kclock.elf`
$objdump_sym_log = `#{$toolchain}objdump -t kclock.elf`
$size_log = `#{$toolchain}size kclock.elf`

###############################################################################
# Read the *.su files (generated by GCC with '-fstack-usage' option)          #
###############################################################################

$self_stack_size = {}
$total_stack_size  = {}

Find.find("src") { |filename|
  next unless filename =~ /.*\.su$/
  File.open(filename).each_line {|l|
    if l =~ /\:([^\:\s]+)\s+(\d+)\s+(\w+)$/
      $self_stack_size[$1] = [$2.to_i, ($self_stack_size[$1] || 0)].max
    end
  }
}

if $self_stack_size.size == 0
  abort("Error: could not load anything from *.su files in 'src' directory.\n" +
        "Please ensure that you are using '-fstack-usage' GCC option.\n")
end

###############################################################################
# Parse the objdump log                                                       #
###############################################################################

$detected_cycles = {}
$labels = {}
$edges = {}
$functions = {}
$refs = {}
$xrefs = {}
$max_stack_size = 0
$critical_path = {}

$objdump_sym_log.each_line {|l|
  $functions[$1] = 1 if l =~ /F\s+\.text.*?(\S+)$/
}

current_func = "entry"
$objdump_dis_log.each_line {|l|
  current_func = $1 if l =~ /^\h+\s+\<(.*?)>\:$/ && $functions.has_key?($1)
  if l =~ /(.*?)<(.*?)(\+0x\h+)?>/ && $2 != current_func
    cmd = $1
    func_name = $2
    $edges[[current_func, func_name]] = 1
    $refs[current_func] = {} if !$refs.has_key?(current_func)
    $refs[func_name] = {} if !$refs.has_key?(func_name)
    $refs[current_func][func_name] = ($self_stack_size[func_name] || 0)

    $xrefs[current_func] = {} if !$xrefs.has_key?(current_func)
    $xrefs[func_name] = {} if !$xrefs.has_key?(func_name)
    $xrefs[func_name][current_func] = ($self_stack_size[current_func] || 0)
  end
}

def recursive_walk(node, visited_nodes, total_stack)
  $total_stack_size[node] = [total_stack, ($total_stack_size[node] || 0)].max
  if $total_stack_size[node] > $max_stack_size
    $critical_path = visited_nodes.clone
    $max_stack_size = $total_stack_size[node]
  end
  $refs[node].each {|next_node, func_stack|
    if visited_nodes.has_key?(next_node) then
      $detected_cycles[[node, next_node]] = 1
      next
    end
    visited_nodes[next_node] = 1
    recursive_walk(next_node, visited_nodes, total_stack + func_stack + 8)
    visited_nodes.delete(next_node)
  }
end

# Find the 'root' nodes and recursively traverse the graph starting from them
$xrefs.each {|func_name, nodes|
  next if nodes.size != 0
  visited_nodes = {}
  visited_nodes[func_name] = 1
  recursive_walk(func_name, visited_nodes, ($self_stack_size[func_name] || 0))
}

###############################################################################
# Generate .dot file for graphviz                                             #
###############################################################################

$legend = ""
$max_stack_size = $total_stack_size.map { |k, v| v }.max

if $size_log =~ /(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\h+)\s+kclock.elf/
    text_size = $1.to_i
    data_size = $2.to_i
    bss_size = $3.to_i
    ram_total = 64 * 1024 # see ld/kitchen.ld
    # "RAM used" is .data + .bss + stack; .text is in ROM
    ram_used = data_size + bss_size + $max_stack_size
    stack_total = ram_total - data_size - bss_size

    $legend << sprintf("------------- kclock.elf --------------\\l")
    $legend << sprintf("text        = %5d bytes\\l", text_size)
    $legend << sprintf("data        = %5d bytes\\l", data_size)
    $legend << sprintf("bss         = %5d bytes\\l", bss_size)
    $legend << sprintf("stack usage = %5d bytes\\l", $max_stack_size)
    $legend << sprintf("stack total = %5d bytes\\l", stack_total)
    $legend << sprintf("RAM total   = %d bytes\\l", ram_total)
    $legend << sprintf("RAM used    = %d bytes\\l", ram_used)
else
    abort("Error: Can't parse \"size\" tool output\n")
end

if $detected_cycles.size != 0
  $legend << sprintf("--------------------------------------\\l")
  $legend << sprintf("Warning: cycles detected in functions:\\l")
  tmp = {}
  $detected_cycles.each {|k, v|
    tmp[k[0]] = 1
    tmp[k[1]] = 1
  }
  tmp.each {|k, v| $legend << sprintf("    %s\\l", k) }
  $legend << sprintf("Watch for bold red arrows on\\l")
  $legend << sprintf("the call graph picture.\\l")
end

fh = File.open("stackgraph.dot", "w")

$refs.each {|func_name, nodes|
  $labels[func_name] = sprintf("%s\\n[total=%d, self=%d]",
                               func_name,
                               ($total_stack_size[func_name] || 0),
                               ($self_stack_size[func_name] || 0))
}

fh.printf("digraph graphname {\n")
fh.printf("rankdir=LR;\n")
fh.printf("node [shape=box, fontname=arial];\n")

$total_stack_size.each { |k, v|
  next if !$critical_path.has_key?(k)
  fh.printf("\"%s\" [style=filled,color=orange];\n", $labels[k])
}

$edges.each {|k, v|
  if $detected_cycles.has_key?(k) then
    fh.printf("\"%s\" -> \"%s\" [color=\"red\",penwidth=5];\n",
              $labels[k[0]], $labels[k[1]])
  else
    fh.printf("\"%s\" -> \"%s\";\n", $labels[k[0]], $labels[k[1]])
  end
}
fh.printf("legend [shape=box,style=filled,fontname=monospace,fontsize=24," +
          "color=\"lightgray\",label=\"#{$legend}\"];\n")
fh.printf("}\n")
fh.close

`dot -Tpng -o stackgraph.png stackgraph.dot`
